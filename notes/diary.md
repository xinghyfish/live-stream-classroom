# 浮生日记

这个文档主要记录开发时遇到的一些问题和解决方案、一些自己的idea，恰如建筑完成后保留的脚手架的草图，也算是记年轻时候生活的`clog`吧（笑）。

> 高斯的粉丝不要激动，这里并没有任何言外之意，请保持冷静。

## 小记

2022年的上半年，没有如愿返校，而是像两年前一样留在家乡。回想起来，高中毕业后整整36个月，满打满算只有16个月真正留在学校，还是比较唏嘘，怎么也算人生的遗憾，但是比起疫情和战争肆虐的地区生活的民众，又觉得自己非常幸运。
前段时间，整个人都被一种抑郁的情绪包裹，先前积压的情绪一下子聚集成一团乌云将自己围绕起来，总觉得有一种窒息感，对未来的悲观和无力将整个人的精神压倒了。
我自己当然知道这种情绪是非常消极的，也在寻找一些改变的契机。有两个人在这段时间给了我很大的思考。

第一位是SpaceX的创始人Elon Musk。记者问道，SpaceX早期多次火箭试射失败，公司命悬一线时，他有想过放弃吗，他回答道：

> 要么死的安然，要么活的绚烂。

第二位是MIT的计算机博士周信静。他在一所职业类高中考上大专，并完成了专升本，在杭电修读学士学位，在浙江大学修读硕士学位，在20年收到了MIT的博士offer。
这他妈才是programmer！

小叙片刻，聊以慰藉，以下正文。（2022年5月13日晚）

# 概述
本项目为在线教学直播平台，主要需要实现以下功能：
- [x] 登录注册页面
- [x] 教师端主页及其相关逻辑
- [x] 学生端主页及其相关逻辑
- [x] 直播间界面
- [ ] 课程检索并添加
- [x] Web端在线聊天（必做）
- [ ] Web端在线音频信息传输（必做）
- [x] Web端白板（必做）
- [x] Web端签到功能（选做）
下面主要针对以上主要功能设计的核心技术进行简要的设计和说明。具体的细节参考相关代码即可。这里主要针对实现时对web程序开发的技术考量和实现时遇到的问题进行简单的记录。深层次的问题可以在项目的issues中进行讨论。

## 1 WebSocket
在课程第一阶段的聊天室的演示中，由于工期较短（实际上是前期摸鱼），当时采取的策略是将用户发送的消息存储到数据库，通过数据库实现聊天记录的存储和历史消息的呈现。但是这样的实现方案出现了一些问题：服务器无法将A用户发送的消息即时推送给用户B，因此用户B无法即时接受用户A的消息。
当时选择了一个非常草率的方案解决这个问题——通过前端内嵌一个自动刷新函数，50ms自动刷新一次，将用户的聊天记录通过后端来传递给前端，而不是通过服务器。这虽然在表面上解决了即时呈现用户消息的功能，但是在【聊天记录】这一功能无法实现。初步分析结果为过于频繁的刷新导致`Javascript`脚本执行被中断。
因此，在最终的项目实现中，决定痛改前非，将之前看到的`websocket`应用到直播间聊天室这一场景中。

### 1.1 介绍

- 教程：https://www.ruanyifeng.com/blog/2017/05/websocket.html

#### 1.1.1 前世今生
在互联网中，最广泛使用的协议是`http`协议。`http`协议由客户端发起，用于向服务器请求资源。但是该协议的缺陷在于其**单向性**，即服务器无法主动向客户端推送信息。
如果服务器的状态连续发生改变，客户端很难获取，必须采取**轮询**策略，了解服务器状态是否发生变化。轮询策略本质上是不断进行请求，因此会不断进行HTTP连接，或者一直保持连接，效率很低。因此，`websocket`应运而生。

#### 1.1.2 简介
Websocket协议的原理如下图所示。客户端首先向服务器发出请求(挥手)，服务器作出响应后，建立连接(双向平等对话)。之后，客户端和服务器均可以向对方主动推送消息。

![HTTP vs Websocket](https://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png)

Websocket具有如下特点：
1. 建立在TCP协议上
2. 和HTTP协议兼容性好，默认端口也是`80`和`443`，且握手阶段采用http协议，能通过各种http代理服务器
3. 协议的**标识符**为`ws`（加密为`wss`），服务器地址为URL

### 1.2 客户端API
##### 1 构造函数

构造函数如下：
```js
var ws = new WebSocket('ws://' + window.location.host + '/');
```
执行上述语句后，客户端就会和服务器相连接。如果没有异常，`websocket`连接即建立。
如果希望用户打开网站即连接，则可以将初始化动作写在`onLoad()`函数中。

##### 2. 状态
`readyState`返回实例对象当前的状态，共有四种：
- `CONNECTING`：`0`，表示正在连接
- `OPEN`：`1`，表示连接成功，可以通信
- `CLOSING`：`2`，表示连接正在关闭
- `CLOSED`：`3`，表示连接已经关闭或者打开连接失败

上面的状态可用于异常处理。

##### 3. `onopen`属性
实例对象的`onopen`属性，用于指定连接成功后的回调函数。
```js
ws.open = function() {
    ws.send('Hello Server!');
}
```
可以通过添加监听器来指定多个回调函数：
```js
ws.addEventListener('open', function() {
    ws.send('Hello World!');
});
```

##### 4. `onclose`属性
```js
ws.onclose = function(event) {
	var code = event.code;
	var reason = event.reason;
	var wasClean = event.wasClean;
	// handle close event
};
```

##### 5. `onmessage`属性
实例对象的`onmessage`属性，用于指定收到服务器数据后的回调函数。
```js
ws.onmessage = function(event) {
	var data = event.data;
	// 服务器发送来数据
};
```

##### 6. `send()`方法
实例对象的`send()`方法用于向服务器发送数据。
例如，发送文本：
```js
ws.send('message');
```

### 1.3 客户端
客户端的`websocket`实现主要根据后端所选用的框架，一般后端框架都会内置相关的类或函数来处理。
在本项目中，后端采用`tornado`框架，`tornado`框架采用`OO`的思想，在路由表中注册一个继承`tornado.websocket.WebSocketHandler`的类，并实现和前端对应的方法即可和前端进行通信。

### 1.4 实现概述
#### 1.4.1 聊天室
基于上述特点，根据教程内容可以了解客户端API。由于这是一个web端的应用，客户端API主要是用`js`实现。服务器端的实现则多种多样，这里选用的是后端框架`tornado`，通过路由表将协议交给对应的`Handler`处理（继承父类），
本项目中聊天室客户端代码参考`/client/view/live.html`，服务器端代码参考`main.py`（路由表）和`/client/controller/websocket.py`。

实现聊天室功能时，用户从前端进行信息的发送操作；客户端的`js`代码对用户的发送消息按钮点击动作进行监听，一旦产生动作，则通过ws协议来传输用户信息到服务器。在服务器端，由于后端采用的是`python`的`tornado`框架，因此需要实现`webscoket controller`来对用户的ws请求做出相应。相应的内容主要是存储用户的消息记录到服务器的不同位置。同时，由于前端使用vue作为框架，因此服务器的相应内容被客户端的`js`代码获取后，用户发送的消息也被同步更新到前端的vue组件中，这样其余用户就可以看到用户发送的消息。通过这样一种模式，可以在前后端进行双向的信息同步，避免了原本的刷新动作，这样，用户也可以正常对聊天记录进行下载。

#### 1.4.2 签到
在设计签到部分的业务逻辑时，我们还是选择websocket协议来实现。签到部分在刚开始设计时没有把流程捋的很顺，导致在前期设计时陷入了混乱。所以决定先把逻辑理顺再开始写代码。

签到部分之所以陷入混乱，是因为在【签到】这个业务上，【教师】和【学生】两个身份是不对等的，而在【聊天室】中，二者处于身份对等的关系，服务器和客户端在交互时不需要区分教师用户和学生用户（除非在有新的需求，这里我们不考虑）。而签到时，我们假定只有教师才有权限发布签到（和项目要求“体现教师和学生两种身份”相契合），而学生只需要负责确认签到，而教师不需要确认签到。基于上述需求，我们需要将客户端区分为教师端、学生端，因此业务逻辑如下：
- 【教师端】==>【服务器】发布签到
- 【服务器】==>【学生端】发送签到确认
- 【学生端】==>【服务器】确认签到
- 【服务器】将签到信息写入签到记录册中

因此，在具体实现时，需要区分客户端的身份。二者的共同点是：都向服务器发送消息，而不同点在于服务器只需要向学生端发送信息。因此，服务器发送消息只需要通过用户的ID（这里是用户名）来屏蔽教师端即可。而客户端向服务器发送消息时，需要体现区别，因此这里规定以下二者的格式。为了防止编码混乱，这里统一使用ASCII字符作为标准化的信息格式：
- 教师端消息：`start-signup (time)`，表示教师发布签到
- 学生端消息：`confirm-signup <username>`，表示学生确认签到；`refuse-signup <username>`，表示学生拒绝签到

如果遵循该协议，则服务器只需要检查消息头(header)，即可区分客户端类型和消息类型，从而进行更加准确的判断。

在需求分析文档中，我们还提到，教师可以发布【限时签到】。为了保证公平性，限时签到从用户接收到服务器的签到消息后开始计时，如果用户没有及时签到则视为没有签到，客户端将自动发送`refuse-signup`的消息给服务器。

## 2 WebRTC
刚开始进行直播功能开发时，考虑使用`ffmpeg`进行推拉流，但是在实际实验时由于延迟过高、浏览器抛弃flash的原因，在中期决定放弃`ffmpeg`，转而使用期中汇报时其他同学推荐的`WebRTC`技术。
在使用了官方提供的demo进行实验（以及在虚拟机硬件设备的获取上踩了大坑）后，终于成功使用了`WebRTC`，发现延迟几乎可以忽略，完美符合我们的需求（渣渣笔记本前置摄像头的像素问题几乎无法用软件解决，忽略就好||即使渣渣笔记本依然无法遮盖本人的逆天颜值，可惜没有选一个吃颜值的饭碗）。
做完demo之后，就开始了前端的开发，这一部分的内容就暂时忽略了……直到前端的界面开发基本完成后，可以开始正式使用`WebRTC`技术来进行实时多人视频聊天功能的实现。

### 2.1 概述
`WebRTC`技术是一种P2P的技术。虽然是P2P，但是在握手的过程中，依然需要服务器的介入来完成身份信息的交换当身份信息交换完成后，浏览器之间就可以直接传输数据，不需要经过服务器。在`WebRTC`中，负责身份信息交换的服务器被称为**信令服务器**(*Signaling server*)，**信令**是一个协调沟通的过程，需要交换如下信息：
1. 连接控制消息（控制通信开启/关闭）
2. 发生错误时彼此告知的信息
3. 媒体流元数据（解码器、解码器配置、带宽、媒体类型等等）
4. 用来建立安全连接的关键数据
5. 外界所看到的网络上的数据（IP地址、端口等）

因此，我们需要构建一个信令服务器。常用的方法就是使用`Node.js`下的`socket.io`库来实现`WebRTC`信令服务器。

# 踩坑记录
## 前后端框架
### 后端`tornado`框架和前端`vue`框架双花括号`{{  }}`冲突问题
在设计成员列表时，由于需要把`vue`组件中的数据用`v-for`列表渲染读取出来，之后，就自然而然用`vue`中数据渲染的方法，之后领取`NameError`大礼包一份。
刚开始我尝试把出错的代码复制到隔离的环境`demo/vue-demo.html`中，想知道是哪里出了问题，结果诡异的事情发生了：在隔离的环境中竟然跑通了……但是在直播页面却跑不通。常言道：
> 事出反常必有妖。

其实问题的核心在于：开发环境和隔离的测试环境有什么差异呢？进过搜索，发现`NameError`是python的错误，而在测试环境中，由于是纯粹的前端`vue`框架，并没有涉及到后端的`tornado`框架，所以才没有报错。
之后，我仔细盯着二者的差异沉思许久，终于发现——可能是前后端框架的冲突。因为无论我前端变量名怎么改，都会出现相同的错误信息。可能是`jinja`和`vue`用双花括号渲染时冲突，优先渲染模板变量，导致在后端传递的参数中并没有这个变量，出现`NameError`。
搜索了相关的内容之后，发现确实是这个问题。解决方案也很简单：在`vue`组件中添加一条属性：
```js
const app = new Vue({
    delimiters: ['[[', ']]'],
    el: '#app',
    //...
});
```
其中`delimiters`属性是一个字符串数组，默认值为`['{{', '}}'']`，也就是默认的渲染样式。这里改成自定义的双方括号（也可以改成其他的，只要确保不会产生歧义或者新的冲突）。
这样，在渲染`vue`的数据时就不会导致后端的`NameError`了。

### 前端`vue`组件数据刷新后消失
在设计成员列表的数据结构时，打算在聊天室部分的`websocket`处理用户连接时将用户的相关信息添加到`vue`组件中，直接从前端过（存储到后端数据库意义不大）。但是又想到了一个问题：刷新网页可能会使前端的数据丢失。
初步构思了两个方案：1. 重新开一个`websocket`连接，这样会产生数据冗余，而且对维护不利；2. 尝试`vue`是否存在缓存功能，这个方案比较理想，优先尝试。

## 开发环境
### 开发环境的设置
由于开发时遇到一些小问题，导致pycharm中的项目无法通过内置插件将暂存的文件同步到远程的代码仓库，因此后来进行代码同步时使用vscode。vscode+各类插件可以给用户很好的开发体验，虽然在代码检测、提示上相较于pycharm这样的IDE还有所欠缺，但是vscode使用的体验就是定制化更高，更加有geek的感觉。
那么问题来了：在vscode上运行项目时，加载配置文件的过程中会出现错误：
```python
FileNotFoundError: [Errno 2] No such file or directory: 'conf/server.conf'
```
例如本项目中，tornado需要读取文件夹`config/server.config`来完成初始化配置，但是在vscode上运行`main.py`时显示无法找到该配置文件。经过检索发现，需要在vscode中设置一些内容，如下：
- 打开`文件->首选项->设置`（英文路径为`File->Preference->Settings`），搜索`Execute in File Dir`，将这个项目打上勾（√），表示在终端执行文件时，是否在文件目录中使用执行，而不是在当前打开的文件夹（原文是When executing a file in the terminal, whether to use execute in the file's directory, instead of the current open folder）。
- 由于vscode的默认设置，运行python并不切换到文件所在的文件夹下（没有`cd`到`main.py`所在目录，而是直接执行，`os.path`并不包含文件所在文件夹），因此找不到同文件夹下的其他文件。通过上面的配制方法可以修改该默认设置。
- **参考文章**：
  - https://www.zhihu.com/question/388688408
  - https://blog.csdn.net/weixin_38003425/article/details/114895764
- 简中互联网上的部分博客声称是“因为没有访问C盘的权限，转移到D盘”纯粹是扯淡，追究问题还是要寻根到底，并不只是在表面上解决问题。

### `python`中的`open()`函数：文件名和路径
> 大坑，整整踩了一个晚上才解决，说多了都是泪，整的我怀疑人生了。

在实现聊天室和签到时，我们需要将中间产生的数据存储到服务器中，例如聊天记录、签到记录。这里实现的方法比较朴素，就是将数据写到文件（`txt`或者`csv`）中。
一个典型的场景就是：当服务器接收到来自学生的确认签到消息时，服务器将学生的姓名、签到时间、签到情况写入到该课程的签到表中。因此，通过后端创建或读写文件来实现这个功能。
由于后端选取的是`python`的`tornado`框架，因此读写文件通常使用`open()`，`mode`参数一般设为`a`，表示追加，在该模式下，如果文件不存在，则会自动创建，我就信心满满地写到：
```python
filepath = "resources/%s/%s/" % (teacherName, courseName)
filename = username + ".txt"
with open(filepath + filename, "a") as fp:
    fp.write(message)
```
看似自然而然，但是，最诡异的事情发生了：运行到这个函数总会提示：
```python
FileNotFoundError: [Errno 2] No such file or directory: 'resources/history/James/操作系统/James.txt'
# James表示教师名，操作系统为课程名，James.txt表示这个是用户James的聊天记录。
```
`mode='a'`会自动创建文件，这里竟然报错了。这就引人深思了。
于是，我在隔离的测试环境中创建了把读写的部分单独写成一个模块`demo/io-demo/io.py`。经过一番调试，发现如果文件所在的路径`filepath`本身存在，或者`open()`函数的文件名参数不加路径，才能成功创建新文件（如果之前不存在）。这意味着如果仅仅使用`open()`函数是无法创建文件夹的，这样和我们的期望是不一致的，因为教师可以自定义添加课程，不可能提前创建好文件。
其实到这里问题就解决了——`open(filepath + filename, 'a')`函数无法创建路径，只有`os.makedirs(filepath)`才能够创建路径，必须要确保该路径已存在才能够创建文件。真相大白之后，调试，成功。
tips: 由于文件路径需要多次使用，这里单独写成了一个接口，在接口中进行路径的创建和生成，之后所有关于路径的代码只需要在接口中调试即可。
这个故事告诉我们：**文件**和**文件夹（路径）**是不一样的，在创建文件时一定要先检查路径是否存在，如果不存在则必须先创建路径。