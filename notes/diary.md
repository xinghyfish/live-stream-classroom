# 浮生日记

这个文档主要记录开发时遇到的一些问题和解决方案、一些自己的idea，恰如建筑完成后保留的脚手架的草图，也算是记年轻时候生活的`clog`吧（笑）。

> 高斯的粉丝不要激动，这里并没有任何言外之意，请保持冷静。

## 小记

2022年的上半年，没有如愿返校，而是像两年前一样留在家乡。回想起来，高中毕业后整整36个月，满打满算只有16个月真正留在学校，还是比较唏嘘，怎么也算人生的遗憾，但是比起疫情和战争肆虐的地区生活的民众，又觉得自己非常幸运。
前段时间，整个人都被一种抑郁的情绪包裹，先前积压的情绪一下子聚集成一团乌云将自己围绕起来，总觉得有一种窒息感，对未来的悲观和无力将整个人的精神压倒了。
我自己当然知道这种情绪是非常消极的，也在寻找一些改变的契机。有两个人在这段时间给了我很大的思考。

第一位是SpaceX的创始人Elon Musk。记者问道，SpaceX早期多次火箭试射失败，公司命悬一线时，他有想过放弃吗，他回答道：

> 要么死的安然，要么活的绚烂。

第二位是MIT的计算机博士周信静。他在一所职业类高中考上大专，并完成了专升本，在杭电修读学士学位，在浙江大学修读硕士学位，在20年收到了MIT的博士offer。
这他妈才是programmer！

小叙片刻，聊以慰藉，以下正文。（2022年5月13日晚）

# 概述
本项目为在线教学直播平台，主要需要实现以下功能：
- [x] Web端在线聊天（必做）
- [ ] Web端在线音频信息传输（必做）
- [x] Web端白板（必做）
- [ ] Web端签到功能（必做）
下面主要针对以上四个主要功能设计的核心技术进行简要的设计和说明。具体的细节参考相关代码即可。这里主要针对实现时对web程序开发的技术考量和实现时遇到的问题进行简单的记录。深层次的问题可以在项目的issues中进行讨论。

## WebSocket
在课程第一阶段的聊天室的演示中，由于工期较短（实际上是前期摸鱼），当时采取的策略是将用户发送的消息存储到数据库，通过数据库实现聊天记录的存储和历史消息的呈现。但是这样的实现方案出现了一些问题：服务器无法将A用户发送的消息即时推送给用户B，因此用户B无法即时接受用户A的消息。
当时选择了一个非常草率的方案解决这个问题——通过前端内嵌一个自动刷新函数，50ms自动刷新一次，将用户的聊天记录通过后端来传递给前端，而不是通过服务器。这虽然在表面上解决了即时呈现用户消息的功能，但是在【聊天记录】这一功能无法实现。初步分析结果为过于频繁的刷新导致`Javascript`脚本执行被中断。
因此，在最终的项目实现中，决定痛改前非，将之前看到的`websocket`应用到直播间聊天室这一场景中。

### 介绍

- 教程：https://www.ruanyifeng.com/blog/2017/05/websocket.html

#### 1. 前世今生
在互联网中，最广泛使用的协议是`http`协议。`http`协议由客户端发起，用于向服务器请求资源。但是该协议的缺陷在于其**单向性**，即服务器无法主动向客户端推送信息。
如果服务器的状态连续发生改变，客户端很难获取，必须采取**轮询**策略，了解服务器状态是否发生变化。轮询策略本质上是不断进行请求，因此会不断进行HTTP连接，或者一直保持连接，效率很低。因此，`websocket`应运而生。

#### 2. 简介
Websocket协议的原理如下图所示。客户端首先向服务器发出请求(挥手)，服务器作出响应后，建立连接(双向平等对话)。之后，客户端和服务器均可以向对方主动推送消息。
![HTTP vs Websocket](https://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png)
Websocket具有如下特点：
1. 建立在TCP协议上
2. 和HTTP协议兼容性好，默认端口也是`80`和`443`，且握手阶段采用http协议，能通过各种http代理服务器
3. 协议的**标识符**为`ws`（加密为`wss`），服务器地址为URL

### 实现概述
基于上述特点，根据教程内容可以了解客户端API。由于这是一个web端的应用，客户端API主要是用`js`实现。服务器端的实现则多种多样，这里选用的是后端框架`tornado`，通过路由表将协议交给对应的`Handler`处理（继承父类），
本项目中聊天室客户端代码参考`/client/view/live.html`，服务器端代码参考`main.py`（路由表）和`/client/controller/websocket.py`。

实现聊天室功能时，用户从前端进行信息的发送操作；客户端的`js`代码对用户的发送消息按钮点击动作进行监听，一旦产生动作，则通过ws协议来传输用户信息到服务器。在服务器端，由于后端采用的是`python`的`tornado`框架，因此需要实现`webscoket controller`来对用户的ws请求做出相应。相应的内容主要是存储用户的消息记录到服务器的不同位置。同时，由于前端使用vue作为框架，因此服务器的相应内容被客户端的`js`代码获取后，用户发送的消息也被同步更新到前端的vue组件中，这样其余用户就可以看到用户发送的消息。通过这样一种模式，可以在前后端进行双向的信息同步，避免了原本的刷新动作，这样，用户也可以正常对聊天记录进行下载。

## WebRTC
刚开始进行直播功能开发时，考虑使用`ffmpeg`进行推拉流，但是在实际实验时由于延迟过高、浏览器抛弃flash的原因，在中期决定放弃`ffmpeg`，转而使用期中汇报时其他同学推荐的`WebRTC`技术。
在使用了官方提供的demo进行实验（以及在虚拟机硬件设备的获取上踩了大坑）后，终于成功使用了`WebRTC`，发现延迟几乎可以忽略，完美符合我们的需求（渣渣笔记本前置摄像头的像素问题几乎无法用软件解决，忽略就好||即使渣渣笔记本依然无法遮盖本人的逆天颜值，可惜没有选一个吃颜值的饭碗）。
做完demo之后，就开始了前端的开发，这一部分的内容就暂时忽略了……直到前端的界面开发基本完成后，可以开始正式使用`WebRTC`技术来进行实时多人视频聊天功能的实现。

### 概述
`WebRTC`技术是一种P2P的技术。虽然是P2P，但是在握手的过程中，依然需要服务器的介入来完成身份信息的交换当身份信息交换完成后，浏览器之间就可以直接传输数据，不需要经过服务器。在`WebRTC`中，负责身份信息交换的服务器被称为**信令服务器**(*Signaling server*)，**信令**是一个协调沟通的过程，需要交换如下信息：
1. 连接控制消息（控制通信开启/关闭）
2. 发生错误时彼此告知的信息
3. 媒体流元数据（解码器、解码器配置、带宽、媒体类型等等）
4. 用来建立安全连接的关键数据
5. 外界所看到的网络上的数据（IP地址、端口等）

因此，我们需要构建一个信令服务器。常用的方法就是使用`Node.js`下的`socket.io`库来实现`WebRTC`信令服务器。
