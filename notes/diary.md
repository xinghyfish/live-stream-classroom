# 浮生日记

这个文档主要记录开发时遇到的一些问题和解决方案、一些自己的idea，恰如建筑完成后保留的脚手架的草图，也算是记年轻时候生活的`clog`吧（笑）。

> 高斯的粉丝不要激动，这里并没有任何言外之意，请保持冷静。

## 小记

2022年的上半年，没有如愿返校，而是像两年前一样留在家乡。回想起来，高中毕业后整整36个月，满打满算只有16个月真正留在学校，还是比较唏嘘，怎么也算人生的遗憾，但是比起疫情和战争肆虐的地区生活的民众，又觉得自己非常幸运。
前段时间，整个人都被一种抑郁的情绪包裹，先前积压的情绪一下子聚集成一团乌云将自己围绕起来，总觉得有一种窒息感，对未来的悲观和无力将整个人的精神压倒了。
我自己当然知道这种情绪是非常消极的，也在寻找一些改变的契机。有两个人在这段时间给了我很大的思考。

第一位是SpaceX的创始人Elon Musk。记者问道，SpaceX早期多次火箭试射失败，公司命悬一线时，他有想过放弃吗，他回答道：

> 要么死的安然，要么活的绚烂。

第二位是MIT的计算机博士周信静。他在一所职业类高中考上大专，并完成了专升本，在杭电修读学士学位，在浙江大学修读硕士学位，在20年收到了MIT的博士offer。
这他妈才是programmer！

小叙片刻，聊以慰藉，以下正文。（2022年5月13日晚）

# 概述
本项目为在线教学直播平台，主要需要实现以下功能：
- [x] 登录注册页面
- [x] 教师端主页及其相关逻辑
- [x] 学生端主页及其相关逻辑
- [x] 直播间界面
- [ ] 课程检索并添加
- [x] Web端在线聊天（必做）
- [x] Web端在线音频信息传输（必做）
- [x] Web端白板（必做）
- [x] Web端签到功能（选做）
下面主要针对以上主要功能设计的核心技术进行简要的设计和说明。具体的细节参考相关代码即可。这里主要针对实现时对web程序开发的技术考量和实现时遇到的问题进行简单的记录。深层次的问题可以在项目的issues中进行讨论。

## 1 WebSocket
在课程第一阶段的聊天室的演示中，由于工期较短（实际上是前期摸鱼），当时采取的策略是将用户发送的消息存储到数据库，通过数据库实现聊天记录的存储和历史消息的呈现。但是这样的实现方案出现了一些问题：服务器无法将A用户发送的消息即时推送给用户B，因此用户B无法即时接受用户A的消息。
当时选择了一个非常草率的方案解决这个问题——通过前端内嵌一个自动刷新函数，50ms自动刷新一次，将用户的聊天记录通过后端来传递给前端，而不是通过服务器。这虽然在表面上解决了即时呈现用户消息的功能，但是在【聊天记录】这一功能无法实现。初步分析结果为过于频繁的刷新导致`Javascript`脚本执行被中断。
因此，在最终的项目实现中，决定痛改前非，将之前看到的`websocket`应用到直播间聊天室这一场景中。

### 1.1 介绍

- 教程：https://www.ruanyifeng.com/blog/2017/05/websocket.html

#### 1.1.1 前世今生
在互联网中，最广泛使用的协议是`http`协议。`http`协议由客户端发起，用于向服务器请求资源。但是该协议的缺陷在于其**单向性**，即服务器无法主动向客户端推送信息。
如果服务器的状态连续发生改变，客户端很难获取，必须采取**轮询**策略，了解服务器状态是否发生变化。轮询策略本质上是不断进行请求，因此会不断进行HTTP连接，或者一直保持连接，效率很低。因此，`websocket`应运而生。

#### 1.1.2 简介
Websocket协议的原理如下图所示。客户端首先向服务器发出请求(挥手)，服务器作出响应后，建立连接(双向平等对话)。之后，客户端和服务器均可以向对方主动推送消息。

![HTTP vs Websocket](https://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png)

Websocket具有如下特点：
1. 建立在TCP协议上
2. 和HTTP协议兼容性好，默认端口也是`80`和`443`，且握手阶段采用http协议，能通过各种http代理服务器
3. 协议的**标识符**为`ws`（加密为`wss`），服务器地址为URL

### 1.2 客户端API
##### 1 构造函数

构造函数如下：
```js
var ws = new WebSocket('ws://' + window.location.host + '/');
```
执行上述语句后，客户端就会和服务器相连接。如果没有异常，`websocket`连接即建立。
如果希望用户打开网站即连接，则可以将初始化动作写在`onLoad()`函数中。

##### 2. 状态
`readyState`返回实例对象当前的状态，共有四种：
- `CONNECTING`：`0`，表示正在连接
- `OPEN`：`1`，表示连接成功，可以通信
- `CLOSING`：`2`，表示连接正在关闭
- `CLOSED`：`3`，表示连接已经关闭或者打开连接失败

上面的状态可用于异常处理。

##### 3. `onopen`属性
实例对象的`onopen`属性，用于指定连接成功后的回调函数。
```js
ws.open = function() {
    ws.send('Hello Server!');
}
```
可以通过添加监听器来指定多个回调函数：
```js
ws.addEventListener('open', function() {
    ws.send('Hello World!');
});
```

##### 4. `onclose`属性
```js
ws.onclose = function(event) {
	var code = event.code;
	var reason = event.reason;
	var wasClean = event.wasClean;
	// handle close event
};
```

##### 5. `onmessage`属性
实例对象的`onmessage`属性，用于指定收到服务器数据后的回调函数。
```js
ws.onmessage = function(event) {
	var data = event.data;
	// 服务器发送来数据
};
```

##### 6. `send()`方法
实例对象的`send()`方法用于向服务器发送数据。
例如，发送文本：
```js
ws.send('message');
```

### 1.3 客户端
客户端的`websocket`实现主要根据后端所选用的框架，一般后端框架都会内置相关的类或函数来处理。
在本项目中，后端采用`tornado`框架，`tornado`框架采用`OO`的思想，在路由表中注册一个继承`tornado.websocket.WebSocketHandler`的类，并实现和前端对应的方法即可和前端进行通信。

### 1.4 实现概述
#### 1.4.1 聊天室
基于上述特点，根据教程内容可以了解客户端API。由于这是一个web端的应用，客户端API主要是用`js`实现。服务器端的实现则多种多样，这里选用的是后端框架`tornado`，通过路由表将协议交给对应的`Handler`处理（继承父类），
本项目中聊天室客户端代码参考`/client/view/live.html`，服务器端代码参考`main.py`（路由表）和`/client/controller/websocket.py`。

实现聊天室功能时，用户从前端进行信息的发送操作；客户端的`js`代码对用户的发送消息按钮点击动作进行监听，一旦产生动作，则通过ws协议来传输用户信息到服务器。在服务器端，由于后端采用的是`python`的`tornado`框架，因此需要实现`webscoket controller`来对用户的ws请求做出相应。相应的内容主要是存储用户的消息记录到服务器的不同位置。同时，由于前端使用vue作为框架，因此服务器的相应内容被客户端的`js`代码获取后，用户发送的消息也被同步更新到前端的vue组件中，这样其余用户就可以看到用户发送的消息。通过这样一种模式，可以在前后端进行双向的信息同步，避免了原本的刷新动作，这样，用户也可以正常对聊天记录进行下载。

#### 1.4.2 签到
在设计签到部分的业务逻辑时，我们还是选择websocket协议来实现。签到部分在刚开始设计时没有把流程捋的很顺，导致在前期设计时陷入了混乱。所以决定先把逻辑理顺再开始写代码。

签到部分之所以陷入混乱，是因为在【签到】这个业务上，【教师】和【学生】两个身份是不对等的，而在【聊天室】中，二者处于身份对等的关系，服务器和客户端在交互时不需要区分教师用户和学生用户（除非在有新的需求，这里我们不考虑）。而签到时，我们假定只有教师才有权限发布签到（和项目要求“体现教师和学生两种身份”相契合），而学生只需要负责确认签到，而教师不需要确认签到。基于上述需求，我们需要将客户端区分为教师端、学生端，因此业务逻辑如下：
- 【教师端】==>【服务器】发布签到
- 【服务器】==>【学生端】发送签到确认
- 【学生端】==>【服务器】确认签到
- 【服务器】将签到信息写入签到记录册中

因此，在具体实现时，需要区分客户端的身份。二者的共同点是：都向服务器发送消息，而不同点在于服务器只需要向学生端发送信息。因此，服务器发送消息只需要通过用户的ID（这里是用户名）来屏蔽教师端即可。而客户端向服务器发送消息时，需要体现区别，因此这里规定以下二者的格式。为了防止编码混乱，这里统一使用ASCII字符作为标准化的信息格式：
- 教师端消息：`start-signup (time)`，表示教师发布签到
- 学生端消息：`confirm-signup <username>`，表示学生确认签到；`refuse-signup <username>`，表示学生拒绝签到。

如果遵循该协议，则服务器只需要检查消息头(header)，即可区分客户端类型和消息类型，从而进行更加准确的判断。

在需求分析文档中，我们还提到，教师可以发布【限时签到】。为了保证公平性，限时签到从用户接收到服务器的签到消息后开始计时，如果用户没有及时签到则视为没有签到，客户端将自动发送`refuse-signup`的消息给服务器。

在之后的实现中，所有需要`websocket`的功能在前后端分别整合到同一个`WebSocket`类中，通过规定的`json`格式的`type`来进行操作的区分：
- `open-connection`：发起连接
- `close-connection`：终止连接
- `user-message`：用户发送的消息
- `offer-singup`：教师发送的签到请求
- `answer-signup`：学生接受和发送的签到应答
- `offer-member-list`：客户端请求服务器提供成员列表
- `answer-member-list`：服务器应答客户端请求成员列表
- `count-change`：服务器通知客户端当前连接人数发生变化

## 2 WebRTC
刚开始进行直播功能开发时，考虑使用`ffmpeg`进行推拉流，但是在实际实验时由于延迟过高、浏览器抛弃flash的原因，在中期决定放弃`ffmpeg`，转而使用期中汇报时其他同学推荐的`WebRTC`技术。
在使用了官方提供的demo进行实验（以及在虚拟机硬件设备的获取上踩了大坑）后，终于成功使用了`WebRTC`，发现延迟几乎可以忽略，完美符合我们的需求（渣渣笔记本前置摄像头的像素问题几乎无法用软件解决，忽略就好||即使渣渣笔记本依然无法遮盖本人的逆天颜值，可惜没有选一个吃颜值的饭碗）。
做完demo之后，就开始了前端的开发，这一部分的内容就暂时忽略了……直到前端的界面开发基本完成后，可以开始正式使用`WebRTC`技术来进行实时多人视频聊天功能的实现。

### 2.1 概述
`WebRTC`技术是一种P2P的技术。虽然是P2P，但是在握手的过程中，依然需要服务器的介入来完成身份信息的交换当身份信息交换完成后，浏览器之间就可以直接传输数据，不需要经过服务器。在`WebRTC`中，负责身份信息交换的服务器被称为**信令服务器**(*Signaling server*)，**信令**是一个协调沟通的过程，需要交换如下信息：
1. 连接控制消息（控制通信开启/关闭）
2. 发生错误时彼此告知的信息
3. 媒体流元数据（解码器、解码器配置、带宽、媒体类型等等）
4. 用来建立安全连接的关键数据
5. 外界所看到的网络上的数据（IP地址、端口等）

因此，使用WebRTC技术时，首先要通过信令服务器交换双方的Session Description（因此采用的协议为SDP），当双方交换了Session描述后，浏览器双方通过一次握手建立连接后，即可进行媒体流的传输。
由于时间限制，该项目运行在本地局域网中，不需要考虑NAT打洞、https协议等很复杂的场景，只需要关注交换信息、握手、对等通信三个部分。
因此，我们需要构建一个信令服务器。常用的方法就是使用`Node.js`下的`socket.io`库来实现`WebRTC`信令服务器。

### 2.2 前期的思考
媒体流传输也是本项目中一个最核心也是最复杂的问题。我们期望能在直播间界面实时显示出当前正在上课的总人数，并且任意一个用户均可以通过成员列表中的按钮获取用户的视频、屏幕共享。因此，我们需要一个`websocket+webRTC`相结合的技术。

`websocket`用于记录当前直播间的的`websocket`连接。当用户访问成员列表时，视为通过客户端向浏览器发送信息。浏览器在接受到用户的访问请求后，将当前直播间的总人数、成员列表发送到客户端，客户端呈现出成员列表。如果客户需要通过成员列表查看其他用户的媒体流，则双方通过`websocket`交换Session描述，之后建立连接。如果用户不进行其他动作，则保持当前的连接，直到直播结束、对方停止传输或切换到其他页面。

用户的屏幕视频流、摄像头视频流、麦克风语音流都封装到`mediaConstraint`中，作为用户对媒体的选择。当双方需要建立连接时，将自身的媒体流推流到对方浏览器即可。根据用户对前端的动作选择具体推流的类型。
- 屏幕推流（共享屏幕）：https://juejin.cn/post/7026555813384683533

接着，我们需要考虑客户端和服务器通信的各种类型，并通过WebScoket来处理二者的交互。
- 【客户端】==>【服务器】
  - 请求当前成员列表
  - 请求获取某用户的视频流
- 【服务器】==>【客户端】
  - 如果连接发生变化，则通知客户端更新当前在线人数

初步考虑到以上的逻辑，基本能够应对大多数情景了。由于没有找到比较好合并多个`websocket`的方案，因此只能创建多个`websocket`对象，后期可能会通过`json`等封装交互文档信息，通过规定双方通信的格式来实现对不同类型消息的处理。暂时先多创建几个类来分别处理吧。

### 2.3 实践
- 参考文章：
  - https://blog.csdn.net/LT11hka/article/details/109163655#commentBox
  - https://juejin.cn/post/7026555813384683533
  - https://cloud.tencent.com/developer/article/1075384
  - https://cloud.tencent.com/developer/article/1615486
  - https://juejin.cn/post/6844903811409149965#heading-5（白板）
  - https://juejin.cn/post/6887147825113595911#heading-4

第一篇参考文章差不多就是我们期望构建的通信模型。以此为例，我们分析一下通信模型的逻辑。

#### 2.3.1 `WebRTC`底层逻辑
##### 1. 工作流程概述
本来想着先把demo跑通再看原理改进，但是demo跑不通的时候还是得补原理。磨刀不误砍柴工，开干。
首先，我们介绍一下WebRTC技术的流程。下面的图表示一个单向连接（一方发起，另一方接受）的工作流：

![WebRTC工作流程](https://upload-images.jianshu.io/upload_images/26132171-92cf1439d62a28b3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1003/format/webp "单向的WebRTC工作流")

每个客户端都要扮演**发送者**和**接收者**两个角色，为了简化问题分析，我们考虑单向连接的模型。设本地的连接为`Local Connection`，远程的连接为`Remote Connection`。初始化时：
- Peer A创建一个`Local RTCPeerConnection`，简称为`ALC`；
- Peer B创建一个`Remote RTCPeerConnection`，简称`BRC`。

##### 2. 收发双方的工作流
发送方Peer A的工作流程如下：
1. **获取stream**：调用接口`navigator.mediaDevices.getUserMedia(mediaConstraints)`捕捉本地media stream。
2. **添加stream**：`ALC`调用`addTrack()`，将stream添加到发送轨道上。
3. **创建请求**：`ALC`调用`createOffer()`创建一个offer。
4. **创建本地描述**：`ALC`调用`setLocalDescription()`将offer设置为本地描述。
5. **触发`onCandidate`事件**
6. **信令服务器派送信息**：`ALC`触发`onCandidate`事件，通过信令服务器发送`candidate`和`offer`
7. **等待应答**：Peer A等待Peer B的应答消息answer。
8. **设置远端描述**：`ALC`调用`setRemoteDescription()`将anwer设置为远程描述。

接收方Peer B的工作流程如下：
1. **触发ontrack**：`BRC`在接收到媒体时被触发，事件带有媒体信息。
2. **添加ICE候选信息**：`BRC`收到candidate时，添加到本地的`IceCandidate`中。
3. **设置远端描述**：`BRC`接收到offer请求时，调用`setRemoteDescription(offer)`设置远端描述。
4. **创建应答**：`BRC`调用`createAnswer()`创建一个应答。
5. **创建本地描述**：`BRC`调用`setLocalDescription(answer)`设置本地描述。
6. **发送应答**：`BRC`通过信令服务器将anwer发送到Peer A。

#### 2.3.2 实现思路
1. 两个浏览器打开同一个页面，连接到同一个`socket`
2. 此时由一个端点建立连接
   - 发起建立连接的一端发送`offer`（携带信号源信息）
   - 另一端收到`offer`之后，发出响应`answer`（携带信号源信息）
   - `offer`端收到`answer`端信息进行存储
3. 此时，双方均已得到所需要的信息（local端和remote端的信息）
   - 握手的过程中双方有了对方的`localDescription`和`remoteDescription`
   - 上述信息将会**触发**`oncandidate`
   - 监听媒体流信息，一旦其中一方媒体流存在事件，将会触发事件，并将远端的媒体流信息绑定到本地浏览器的媒体流呈现组件上，这样就实现了媒体流信息在不同浏览器之间的传输。

为了能够让远端媒体流能够和本地媒体流进行协同，在不同浏览器中传输媒体流文件，实际实现时，只用了一个`RTCPeerConnection`进行P2P的连接，这个对象在不同浏览器之间是不同的，但是在P2P连接的过程中可以起到类似的作用，这样传输的媒体流看起来就是方向相反的了。

具体的实现参考`live.html`文件中`javascript`部分的`startPeerConnection()`、`createOffer()`、`createAnswer()`函数。在绑定ws事件之后，建立`RTCPeerConnection`并设置`icecandidate`和`addstream`监听器。用户通过用户列表发出发起【查看摄像头】或者【查看屏幕】的操作后，将会发起`createOffer`，封装在`websocket`中通过服务器传输给另一方，另一方接收到后自动触发`createAnswer`，同样通过服务器传输给发起方。这样，双方成功建立连接，触发媒体流传输事件，传递媒体流数据，成功建立实时的媒体流信息传输。（芜湖，大功告成！）

# 踩坑记录
## 前后端框架
### 后端`tornado`框架和前端`vue`框架双花括号`{{  }}`冲突问题
在设计成员列表时，由于需要把`vue`组件中的数据用`v-for`列表渲染读取出来，之后，就自然而然用`vue`中数据渲染的方法，之后领取`NameError`大礼包一份。
刚开始我尝试把出错的代码复制到隔离的环境`demo/vue-demo.html`中，想知道是哪里出了问题，结果诡异的事情发生了：在隔离的环境中竟然跑通了……但是在直播页面却跑不通。常言道：
> 事出反常必有妖。

其实问题的核心在于：开发环境和隔离的测试环境有什么差异呢？进过搜索，发现`NameError`是python的错误，而在测试环境中，由于是纯粹的前端`vue`框架，并没有涉及到后端的`tornado`框架，所以才没有报错。
之后，我仔细盯着二者的差异沉思许久，终于发现——可能是前后端框架的冲突。因为无论我前端变量名怎么改，都会出现相同的错误信息。可能是`jinja`和`vue`用双花括号渲染时冲突，优先渲染模板变量，导致在后端传递的参数中并没有这个变量，出现`NameError`。
搜索了相关的内容之后，发现确实是这个问题。解决方案也很简单：在`vue`组件中添加一条属性：
```js
const app = new Vue({
    delimiters: ['[[', ']]'],
    el: '#app',
    //...
});
```
其中`delimiters`属性是一个字符串数组，默认值为`['{{', '}}'']`，也就是默认的渲染样式。这里改成自定义的双方括号（也可以改成其他的，只要确保不会产生歧义或者新的冲突）。
这样，在渲染`vue`的数据时就不会导致后端的`NameError`了。

### 前端`vue`组件数据刷新后消失
在设计成员列表的数据结构时，打算在聊天室部分的`websocket`处理用户连接时将用户的相关信息添加到`vue`组件中，直接从前端过（存储到后端数据库意义不大）。但是又想到了一个问题：刷新网页可能会使前端的数据丢失。
初步构思了两个方案：1. 重新开一个`websocket`连接，这样会产生数据冗余，而且对维护不利；2. 尝试`vue`是否存在缓存功能，这个方案比较理想，优先尝试。

## 开发环境
### 开发环境的设置
由于开发时遇到一些小问题，导致pycharm中的项目无法通过内置插件将暂存的文件同步到远程的代码仓库，因此后来进行代码同步时使用vscode。vscode+各类插件可以给用户很好的开发体验，虽然在代码检测、提示上相较于pycharm这样的IDE还有所欠缺，但是vscode使用的体验就是定制化更高，更加有geek的感觉。
那么问题来了：在vscode上运行项目时，加载配置文件的过程中会出现错误：
```python
FileNotFoundError: [Errno 2] No such file or directory: 'conf/server.conf'
```
例如本项目中，tornado需要读取文件夹`config/server.config`来完成初始化配置，但是在vscode上运行`main.py`时显示无法找到该配置文件。经过检索发现，需要在vscode中设置一些内容，如下：
- 打开`文件->首选项->设置`（英文路径为`File->Preference->Settings`），搜索`Execute in File Dir`，将这个项目打上勾（√），表示在终端执行文件时，是否在文件目录中使用执行，而不是在当前打开的文件夹（原文是When executing a file in the terminal, whether to use execute in the file's directory, instead of the current open folder）。
- 由于vscode的默认设置，运行python并不切换到文件所在的文件夹下（没有`cd`到`main.py`所在目录，而是直接执行，`os.path`并不包含文件所在文件夹），因此找不到同文件夹下的其他文件。通过上面的配制方法可以修改该默认设置。
- **参考文章**：
  - https://www.zhihu.com/question/388688408
  - https://blog.csdn.net/weixin_38003425/article/details/114895764
- 简中互联网上的部分博客声称是“因为没有访问C盘的权限，转移到D盘”纯粹是扯淡，追究问题还是要寻根到底，并不只是在表面上解决问题。

### `python`中的`open()`函数：文件名和路径
> 大坑，整整踩了一个晚上才解决，说多了都是泪，整的我怀疑人生了。

在实现聊天室和签到时，我们需要将中间产生的数据存储到服务器中，例如聊天记录、签到记录。这里实现的方法比较朴素，就是将数据写到文件（`txt`或者`csv`）中。
一个典型的场景就是：当服务器接收到来自学生的确认签到消息时，服务器将学生的姓名、签到时间、签到情况写入到该课程的签到表中。因此，通过后端创建或读写文件来实现这个功能。
由于后端选取的是`python`的`tornado`框架，因此读写文件通常使用`open()`，`mode`参数一般设为`a`，表示追加，在该模式下，如果文件不存在，则会自动创建，我就信心满满地写到：
```python
filepath = "resources/%s/%s/" % (teacherName, courseName)
filename = username + ".txt"
with open(filepath + filename, "a") as fp:
    fp.write(message)
```

看似自然而然，但是，最诡异的事情发生了：运行到这个函数总会提示：
```python
FileNotFoundError: [Errno 2] No such file or directory: 'resources/history/James/操作系统/James.txt'
# James表示教师名，操作系统为课程名，James.txt表示这个是用户James的聊天记录。
```

`mode='a'`会自动创建文件，这里竟然报错了。这就引人深思了。
于是，我在隔离的测试环境中创建了把读写的部分单独写成一个模块`demo/io-demo/io.py`。经过一番调试，发现如果文件所在的路径`filepath`本身存在，或者`open()`函数的文件名参数不加路径，才能成功创建新文件（如果之前不存在）。这意味着如果仅仅使用`open()`函数是无法创建文件夹的，这样和我们的期望是不一致的，因为教师可以自定义添加课程，不可能提前创建好文件。
其实到这里问题就解决了——`open(filepath + filename, 'a')`函数无法创建路径，只有`os.makedirs(filepath)`才能够创建路径，必须要确保该路径已存在才能够创建文件。真相大白之后，调试，成功。
tips: 由于文件路径需要多次使用，这里单独写成了一个接口，在接口中进行路径的创建和生成，之后所有关于路径的代码只需要在接口中调试即可。
这个故事告诉我们：**文件**和**文件夹（路径）**是不一样的，在创建文件时一定要先检查路径是否存在，如果不存在则必须先创建路径。

## 实现与方案选取
### `WebSocket`实现
前期头铁，前后端写了3个`wobsocket`连接，导致出现了很多数据冗余问题，也为维护增加了困难。在项目后期，顶着出bug的风险重构了整个前后端的`websocket`实现，通过`JSON`传递数据，用`type`规定了每种消息的类型，`key`规定了消息的子类型，`message`规定了具体消息的内容，`data`规定了传输的数据信息，`account`规定了发送方的用户名。
（这种属于简单的重构，即使失败了可以用git进行回滚，问题不大。）

### `WebRTC`实现
由于`ffmpeg`延迟太高，而且延迟会有累积效应，因此在一个月前我们果断抛弃了这个方案，转而选择了`WebRTC`方案这样原生的浏览器媒体流传输工具。但是由于互联网上面大多数的`WebRTC`实现都是在同一个页面上使用`WebSocket`技术来演示视频数据的交换，这样显然不满足我们的要求。我们希望能够直接建立不同浏览器（逻辑上）的通信，而不是在一个页面自嗨，其他浏览器甚至页面无法获取数据。
但是由于`WebRTC`在跨域部署时存在一定的复杂性（bug），因此这里选择在本地部署，不需要考虑打洞的问题。考虑到实际使用的场景，我们将用户的信息存储在cookie中，这样测试和演示时，就必须使用不同浏览器，这也使得我们必须考虑跨浏览器的通信。
刚开始的实现参考了文章[从零实现直播：又是聊天室](https://www.jianshu.com/p/610a046183c6)的方案。这个方案本质上建立了两个`RTCPeerConnection`：`localConnection`和`remoteConnection`，布置在同一个页面中。实践之后发现，这个方案无法在不同浏览器之间传输媒体流，可能是因为媒体流没有走到我们期望的另一端的出口。
踩坑后，决定建立一个`RTCPeerConnection`，让媒体流无处可逃，直接捕获，最后成功了，我的心里只有泪目两个字（2022.6.11-10:03 a.m.）。
虽然最终的方案仍有不完善的地方，但是确实克服了最大的困难，也把本项目最核心的功能实现了。从学期开始时对web技术知识储备几乎为0，到现在（借助复制粘贴技术）实现了在线直播平台，一路走来，也经历了不少的坎坷，走了不少弯路，重构了无数次代码，但是也学习到了很多知识（后端`tornado`和`Flask`框架、画板`canvas`、通信`websocket`、媒体流传输`WebRTC`、前端`vue`框架、`javascript`及其基本衍生库的使用、数据库的实际使用）。学期的技术之旅告一段落，人生的技术之旅刚刚开始，那就扬帆远航吧。